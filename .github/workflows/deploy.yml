name: Deploy to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Build frontend
      working-directory: ./frontend
      run: |
        npm ci
        npm run build

    - name: Deploy to EC2
      env:
        PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        HOSTNAME: ${{ secrets.EC2_HOSTNAME }}
        USER_NAME: ${{ secrets.EC2_USER_NAME }}
        DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        echo "$PRIVATE_KEY" > private_key
        chmod 600 private_key
        
        # Simple DNS resolution - try Cloudflare DNS first (usually fastest to update)
        echo "Resolving ${HOSTNAME}..."
        SSH_TARGET=$(dig @1.1.1.1 +short ${HOSTNAME} | head -n1)
        
        if [[ -z "$SSH_TARGET" ]] || [[ ! "$SSH_TARGET" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "DNS resolution failed. Please check that ${HOSTNAME} points to your EC2 IP and try again in 5 minutes."
          exit 1
        fi
        
        echo "Connecting to ${HOSTNAME} (${SSH_TARGET})"
        
        # Stop services and clean up
        ssh -o StrictHostKeyChecking=no -i private_key ${USER_NAME}@${SSH_TARGET} 'sudo systemctl stop lifeline-backend || true; sudo systemctl stop nginx || true; sudo rm -rf /home/ec2-user/lifeline; mkdir -p /home/ec2-user/lifeline'
        
        # Copy files to temporary locations
        scp -i private_key -r frontend/build/* ${USER_NAME}@${SSH_TARGET}:/tmp/frontend_build/
        scp -i private_key -r backend/* ${USER_NAME}@${SSH_TARGET}:/tmp/backend/
        
        # Move files to proper locations and fix permissions
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} '
          # Create directory structure first
          mkdir -p /home/ec2-user/lifeline/backend
          mkdir -p /home/ec2-user/lifeline/frontend
          
          # Move backend files
          cp -r /tmp/backend/* /home/ec2-user/lifeline/backend/
          
          # Move frontend files
          cp -r /tmp/frontend_build/* /home/ec2-user/lifeline/frontend/
          
          # Fix critical permission issues that cause 500 errors
          chmod 755 /home/ec2-user
          chmod 755 /home/ec2-user/lifeline
          chmod -R 755 /home/ec2-user/lifeline/frontend
          
          # Clean up temp files
          rm -rf /tmp/frontend_build /tmp/backend
        '
        
        # Install and configure Python dependencies
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} 'cd /home/ec2-user/lifeline && python3 -m venv venv && source venv/bin/activate && pip install -r backend/requirements.txt && pip install gunicorn'
        
        # Django setup
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} 'cd /home/ec2-user/lifeline/backend/LifeLine && source /home/ec2-user/lifeline/venv/bin/activate && DJANGO_SECRET_KEY='"'"'${{ secrets.DJANGO_SECRET_KEY }}'"'"' OPENAI_API_KEY='"'"'${{ secrets.OPENAI_API_KEY }}'"'"' python manage.py migrate && DJANGO_SECRET_KEY='"'"'${{ secrets.DJANGO_SECRET_KEY }}'"'"' OPENAI_API_KEY='"'"'${{ secrets.OPENAI_API_KEY }}'"'"' python manage.py collectstatic --noinput'
        
        # Create environment file for systemd
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} 'echo "DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}" | sudo tee /etc/lifeline.env && echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" | sudo tee -a /etc/lifeline.env && sudo chmod 644 /etc/lifeline.env'
        
        # Create systemd service
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} 'echo "[Unit]
        Description=LifeLine Django Backend
        After=network.target
        
        [Service]
        Type=simple
        User=ec2-user
        WorkingDirectory=/home/ec2-user/lifeline/backend/LifeLine
        EnvironmentFile=/etc/lifeline.env
        ExecStart=/home/ec2-user/lifeline/venv/bin/gunicorn LifeLine.wsgi:application --bind 0.0.0.0:8000
        Restart=always
        
        [Install]
        WantedBy=multi-user.target" | sudo tee /etc/systemd/system/lifeline-backend.service'
        
        # Check if HOSTNAME is an IP address or domain and configure SSL accordingly
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} 'if [[ ${HOSTNAME} =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "IP address detected - using self-signed certificate"
          sudo mkdir -p /etc/ssl/private /etc/ssl/certs
          sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /etc/ssl/private/lifeline.key \
            -out /etc/ssl/certs/lifeline.crt \
            -subj "/C=US/ST=State/L=City/O=LifeLine/CN=${HOSTNAME}" \
            -addext "subjectAltName=IP:${HOSTNAME}"
          
          # Create nginx config with self-signed SSL
          echo "server {
            listen 80;
            server_name _;
            return 301 https://\$server_name\$request_uri;
          }
          
          server {
            listen 443 ssl http2;
            server_name _;
            
            ssl_certificate /etc/ssl/certs/lifeline.crt;
            ssl_certificate_key /etc/ssl/private/lifeline.key;
            ssl_protocols TLSv1.2 TLSv1.3;
            
            root /home/ec2-user/lifeline/frontend;
            index index.html;
            
            location / {
              try_files \$uri \$uri/ /index.html;
            }
            
            location /api {
              proxy_pass http://127.0.0.1:8000;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-Proto \$scheme;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            }
          }" | sudo tee /etc/nginx/conf.d/lifeline.conf
        else
          echo "Domain detected: ${HOSTNAME} - setting up Let'\''s Encrypt"
          sudo mkdir -p /etc/ssl/private /etc/ssl/certs
          
          # Install certbot for Let'\''s Encrypt SSL certificates
          sudo yum install -y python3-pip && sudo pip3 install certbot certbot-nginx
          
          # Create initial nginx config without SSL for domain verification
          echo "server {
            listen 80;
            server_name ${HOSTNAME};
            
            location /.well-known/acme-challenge/ {
              root /var/www/html;
            }
            
            root /home/ec2-user/lifeline/frontend;
            index index.html;
            
            location / {
              try_files \$uri \$uri/ /index.html;
            }
            
            location /api {
              proxy_pass http://127.0.0.1:8000;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-Proto \$scheme;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            }
          }" | sudo tee /etc/nginx/conf.d/lifeline.conf
          
          # Create web root for Let'\''s Encrypt verification
          sudo mkdir -p /var/www/html && sudo chown -R nginx:nginx /var/www/html
          
          # Remove conflicting configs
          sudo rm -f /etc/nginx/conf.d/default.conf /etc/nginx/sites-enabled/default
          
          # Test nginx config and start nginx
          sudo nginx -t && sudo systemctl enable nginx && sudo systemctl start nginx
          
          # Wait a moment for nginx to fully start
          sleep 5
          
          # Try to obtain SSL certificate from Let'\''s Encrypt
          echo "Attempting to get SSL certificate for ${HOSTNAME}"
          
          # Ensure DuckDNS record is current before requesting certificate
          echo "Verifying domain points to this server..."
          CURRENT_IP=$(curl -s http://checkip.amazonaws.com/)
          DOMAIN_IP=$(dig +short ${HOSTNAME} @1.1.1.1 | head -n1)
          
          if [[ "$CURRENT_IP" != "$DOMAIN_IP" ]]; then
            echo "WARNING: Domain ${HOSTNAME} points to ${DOMAIN_IP} but this server is ${CURRENT_IP}"
            echo "SSL certificate request may fail due to domain mismatch"
          else
            echo "Domain verification passed: ${HOSTNAME} -> ${CURRENT_IP}"
          fi
          
          # Try Let's Encrypt certificate
          if sudo certbot --nginx -d ${HOSTNAME} --non-interactive --agree-tos --email admin@${HOSTNAME} --redirect --verbose; then
            echo "SSL certificate obtained successfully"
            # Setup automatic certificate renewal
            echo "0 12 * * * /usr/local/bin/certbot renew --quiet" | sudo crontab -
          else
            echo "Let's Encrypt failed. Checking common issues..."
            
            # Check if port 80 is accessible
            echo "Testing port 80 accessibility..."
            if curl -I -m 10 http://${HOSTNAME}/.well-known/acme-challenge/test 2>/dev/null; then
              echo "Port 80 is accessible"
            else
              echo "Port 80 may be blocked - this prevents Let's Encrypt validation"
            fi
            
            echo "SSL certificate failed, falling back to self-signed certificate"
            echo "Note: This will show browser warnings but HTTPS will still work"
            # Create self-signed certificate as fallback
            sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout /etc/ssl/private/lifeline.key \
              -out /etc/ssl/certs/lifeline.crt \
              -subj "/C=US/ST=State/L=City/O=LifeLine/CN=${HOSTNAME}"
            
            # Update nginx config with self-signed certificate
            echo "server {
              listen 80;
              server_name ${HOSTNAME};
              return 301 https://\$server_name\$request_uri;
            }
            
            server {
              listen 443 ssl http2;
              server_name ${HOSTNAME};
              
              ssl_certificate /etc/ssl/certs/lifeline.crt;
              ssl_certificate_key /etc/ssl/private/lifeline.key;
              ssl_protocols TLSv1.2 TLSv1.3;
              
              root /home/ec2-user/lifeline/frontend;
              index index.html;
              
              location / {
                try_files \$uri \$uri/ /index.html;
              }
              
              location /api {
                proxy_pass http://127.0.0.1:8000;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              }
            }" | sudo tee /etc/nginx/conf.d/lifeline.conf
            
            # Reload nginx with new config
            sudo systemctl reload nginx
          fi
        fi'
        
        # Start backend service
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} 'sudo systemctl daemon-reload && sudo systemctl enable lifeline-backend && sudo systemctl start lifeline-backend'
        
        # Fix frontend permissions on EC2
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} 'sudo chown -R nginx:nginx /home/ec2-user/lifeline/frontend && sudo chmod -R 755 /home/ec2-user/lifeline/frontend'
        
        # Check if services are running and debug issues
        ssh -i private_key ${USER_NAME}@${SSH_TARGET} 'echo "=== Service Status ===" && sudo systemctl is-active lifeline-backend && sudo systemctl is-active nginx && echo "=== Port Check ===" && sudo netstat -tulpn | grep -E ":(80|443|8000)" && echo "=== Test Django API health ===" && curl -s http://localhost:8000/api/health/ || echo "API not ready yet" && echo "=== Test HTTP access ===" && curl -I http://localhost:80 && echo "=== Frontend files check ===" && ls -la /home/ec2-user/lifeline/frontend/ && echo "=== Nginx configuration ===" && sudo nginx -t && echo "=== Nginx error log ===" && sudo tail -n 5 /var/log/nginx/error.log || echo "No nginx errors yet"'
