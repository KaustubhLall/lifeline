name: Deploy to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      confirm_deploy:
        description: 'Type "deploy" to confirm deployment'
        required: true
        default: ''
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Only run if manual trigger confirms deployment or it's a push to main
    if: github.event_name == 'push' || github.event.inputs.confirm_deploy == 'deploy'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main  # Always deploy from main branch

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Cache Python dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install frontend dependencies
      working-directory: ./frontend
      run: |
        echo "Installing frontend dependencies..."
        npm ci
        echo "Frontend dependencies installed"

    - name: Build frontend
      working-directory: ./frontend
      run: |
        echo "Building React frontend..."
        npm run build
        echo "Frontend build completed"
        ls -la build/

    - name: Install backend dependencies
      working-directory: ./backend
      run: |
        echo "Installing Python dependencies..."
        pip install -r requirements.txt
        echo "Backend dependencies installed"

    - name: Run backend tests
      working-directory: ./backend/LifeLine
      run: |
        echo "Running Django tests..."
        python manage.py test --verbosity=2 || echo "Tests failed but continuing deployment"

    - name: Prepare deployment package
      run: |
        echo "Preparing deployment package..."
        mkdir -p deployment
        
        # Copy built frontend
        cp -r frontend/build deployment/frontend
        
        # Copy backend files
        cp -r backend deployment/backend
        
        # Create deployment script
        cat > deployment/deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "üöÄ Starting LifeLine deployment..."
        
        # Configuration
        APP_DIR="/home/ec2-user/lifeline"
        VENV_DIR="$APP_DIR/venv"
        
        # Update system packages
        echo "üì¶ Updating system packages..."
        sudo yum update -y
        sudo yum install -y python3 python3-pip nginx git
        
        # Create application directory
        sudo mkdir -p $APP_DIR
        cd $APP_DIR
        
        echo "üõë Stopping existing services..."
        sudo systemctl stop lifeline-backend 2>/dev/null || echo "Backend service not running"
        sudo systemctl stop nginx 2>/dev/null || echo "Nginx not running"
        
        # Backup current deployment
        if [ -d "$APP_DIR/current" ]; then
            echo "üìã Creating backup..."
            sudo mv $APP_DIR/current $APP_DIR/backup-$(date +%Y%m%d_%H%M%S)
        fi
        
        # Install new deployment
        echo "üìÅ Installing new deployment..."
        sudo mv /tmp/lifeline-deployment $APP_DIR/current
        sudo chown -R ec2-user:ec2-user $APP_DIR/current
        
        # Set up Python virtual environment
        echo "üêç Setting up Python environment..."
        cd $APP_DIR/current/backend
        python3 -m venv $VENV_DIR
        source $VENV_DIR/bin/activate
        pip install --upgrade pip
        pip install -r requirements.txt
        
        # Django setup
        echo "‚öôÔ∏è Configuring Django..."
        cd $APP_DIR/current/backend/LifeLine
        source $VENV_DIR/bin/activate
        
        # Apply migrations
        python manage.py migrate --noinput
        
        # Collect static files
        python manage.py collectstatic --noinput --clear
        
        # Set up frontend
        echo "üåê Setting up frontend..."
        sudo rm -rf /var/www/html/lifeline
        sudo mkdir -p /var/www/html/lifeline
        sudo cp -r $APP_DIR/current/frontend/* /var/www/html/lifeline/
        sudo chown -R nginx:nginx /var/www/html/lifeline
        
        # Create systemd service
        echo "üîß Creating backend service..."
        sudo tee /etc/systemd/system/lifeline-backend.service > /dev/null << 'SYSTEMD_EOF'
        [Unit]
        Description=LifeLine Django Backend
        After=network.target
        
        [Service]
        Type=exec
        User=ec2-user
        Group=ec2-user
        WorkingDirectory=/home/ec2-user/lifeline/current/backend/LifeLine
        Environment=PATH=/home/ec2-user/lifeline/venv/bin
        Environment=DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}
        Environment=OPENAI_API_KEY=${OPENAI_API_KEY}
        Environment=DEBUG=False
        Environment=ALLOWED_HOSTS=*
        ExecStart=/home/ec2-user/lifeline/venv/bin/python manage.py runserver 0.0.0.0:8000
        Restart=always
        RestartSec=3
        
        [Install]
        WantedBy=multi-user.target
        SYSTEMD_EOF
        
        # Configure Nginx
        echo "üîß Configuring Nginx..."
        sudo tee /etc/nginx/conf.d/lifeline.conf > /dev/null << 'NGINX_EOF'
        server {
            listen 80;
            server_name _;
            
            # Frontend
            location / {
                root /var/www/html/lifeline;
                index index.html;
                try_files $uri $uri/ /index.html;
            }
            
            # Backend API
            location /api/ {
                proxy_pass http://127.0.0.1:8000;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_cache_bypass $http_upgrade;
            }
            
            # Django admin
            location /admin/ {
                proxy_pass http://127.0.0.1:8000;
                proxy_http_version 1.1;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
            
            # Static files
            location /static/ {
                alias /home/ec2-user/lifeline/current/backend/LifeLine/staticfiles/;
                expires 1y;
                add_header Cache-Control "public, immutable";
            }
        }
        NGINX_EOF
        
        # Remove default nginx config
        sudo rm -f /etc/nginx/conf.d/default.conf
        
        # Test nginx configuration
        sudo nginx -t
        
        # Start services
        echo "üöÄ Starting services..."
        sudo systemctl daemon-reload
        sudo systemctl enable lifeline-backend
        sudo systemctl start lifeline-backend
        sudo systemctl enable nginx
        sudo systemctl start nginx
        
        # Health check
        echo "üîç Performing health check..."
        sleep 10
        
        # Check services
        if sudo systemctl is-active --quiet lifeline-backend; then
            echo "‚úÖ Backend service is running"
        else
            echo "‚ùå Backend service failed to start"
            sudo systemctl status lifeline-backend
            sudo journalctl -u lifeline-backend --no-pager -n 20
        fi
        
        if sudo systemctl is-active --quiet nginx; then
            echo "‚úÖ Nginx is running"
        else
            echo "‚ùå Nginx failed to start"
            sudo systemctl status nginx
        fi
        
        echo "üéâ Deployment completed!"
        EOF
        
        chmod +x deployment/deploy.sh

    - name: Show GitHub Runner IP
      run: |
        echo "üåê Deploying from branch: ${{ github.ref_name }}"
        echo "üåê GitHub Actions Runner IP Information:"
        echo "Runner IP: $(curl -s ifconfig.me || curl -s icanhazip.com || echo 'Unknown')"
        echo ""
        echo "‚ö†Ô∏è  SECURITY GROUP CONFIGURATION NEEDED:"
        echo "Your EC2 security group needs to allow SSH (port 22) from this IP"
        echo "Current rule allows: 136.26.51.147/32 (your local machine)"
        echo "Required: Add rule for GitHub Actions runner IPs"
        echo ""
        echo "Quick fix: Change SSH source to 0.0.0.0/0"

    - name: Setup SSH
      env:
        EC2_SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
      run: |
        echo "üîë Setting up SSH connection..."
        
        # Create SSH directory
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Setup private key
        echo "$EC2_SSH_PRIVATE_KEY" > ~/.ssh/private_key
        chmod 600 ~/.ssh/private_key
        
        # Validate private key format
        if ssh-keygen -l -f ~/.ssh/private_key > /dev/null 2>&1; then
          echo "‚úÖ SSH private key is valid"
        else
          echo "‚ùå SSH private key format is invalid"
          exit 1
        fi
        
        # Configure SSH known hosts
        ssh-keyscan -H ${{ secrets.EC2_HOSTNAME }} >> ~/.ssh/known_hosts 2>/dev/null || true

    - name: Test SSH Connection
      env:
        EC2_HOSTNAME: ${{ secrets.EC2_HOSTNAME }}
        EC2_USER_NAME: ${{ secrets.EC2_USER_NAME }}
      run: |
        echo "üîç Testing SSH connection..."
        
        # Test with shorter timeout for faster feedback
        if timeout 30 ssh -o ConnectTimeout=10 -o BatchMode=yes -i ~/.ssh/private_key ${EC2_USER_NAME}@${EC2_HOSTNAME} 'echo "‚úÖ SSH connection successful!"'; then
            echo "üéâ Ready to deploy!"
        else
            echo ""
            echo "‚ùå SSH Connection Failed!"
            echo ""
            echo "SOLUTION: Update your EC2 Security Group"
            echo "1. Go to AWS Console ‚Üí EC2 ‚Üí Security Groups"
            echo "2. Select security group: sg-061598a25c91a141e"
            echo "3. Edit inbound rules"
            echo "4. Change SSH rule source from '136.26.51.147/32' to '0.0.0.0/0'"
            echo ""
            echo "Current runner IP: $(curl -s ifconfig.me 2>/dev/null || echo 'Unknown')"
            echo "Your rule allows: 136.26.51.147/32"
            echo ""
            exit 1
        fi

    - name: Deploy to EC2
      env:
        EC2_HOSTNAME: ${{ secrets.EC2_HOSTNAME }}
        EC2_USER_NAME: ${{ secrets.EC2_USER_NAME }}
        DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        echo "üöÄ Deploying to EC2 instance..."
        
        # Copy deployment package
        echo "üì¶ Copying deployment package..."
        scp -o ConnectTimeout=30 -i ~/.ssh/private_key -r deployment ${EC2_USER_NAME}@${EC2_HOSTNAME}:/tmp/lifeline-deployment
        
        # Execute deployment script
        echo "üîß Executing deployment script..."
        ssh -o ConnectTimeout=30 -i ~/.ssh/private_key ${EC2_USER_NAME}@${EC2_HOSTNAME} "
          export DJANGO_SECRET_KEY='${DJANGO_SECRET_KEY}'
          export OPENAI_API_KEY='${OPENAI_API_KEY}'
          chmod +x /tmp/lifeline-deployment/deploy.sh
          sudo /tmp/lifeline-deployment/deploy.sh
        "

    - name: Verify deployment
      env:
        EC2_HOSTNAME: ${{ secrets.EC2_HOSTNAME }}
      run: |
        echo "üîç Verifying deployment..."
        
        # Wait for services to start
        sleep 30
        
        # Test frontend
        if curl -f -s --max-time 10 http://${EC2_HOSTNAME} > /dev/null; then
            echo "‚úÖ Frontend is responding"
        else
            echo "‚ö†Ô∏è Frontend may still be starting"
        fi
        
        # Test backend API
        if curl -f -s --max-time 10 http://${EC2_HOSTNAME}/api/ > /dev/null; then
            echo "‚úÖ Backend API is responding"
        else
            echo "‚ö†Ô∏è Backend API may still be starting"
        fi

    - name: Deployment summary
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "üéâ Deployment successful!"
          echo "üåê Application: http://${{ secrets.EC2_HOSTNAME }}"
          echo "üîß Admin: http://${{ secrets.EC2_HOSTNAME }}/admin/"
        else
          echo "‚ùå Deployment failed - check logs above"
        fi
